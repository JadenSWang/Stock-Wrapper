<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>stock_wrapper.visualize API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>stock_wrapper.visualize</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import stock_wrapper

import robin_stocks
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
import matplotlib.dates as md
import seaborn as sns
import plotly.graph_objects as go
from plotly.subplots import make_subplots

import threading
import curses
import time
import numpy as np


class visualize:
    @staticmethod
    def display_stocks(stocks_to_monitor, duration=100):
        &#34;&#34;&#34;Turns the command shell executing into a ticker display
        :param stocks_to_monitor: any stocks you want to watch
        :type stocks_to_monitor: list [str]
        :param duration: duration in seconds, -1 for infinite
        :type duration: int
        &#34;&#34;&#34;
        if len(stocks_to_monitor) &lt; 1:
            return

        class Stocks_Data_Thread(threading.Thread):
            def __init__(self, stocks_to_monitor, duration=100):
                threading.Thread.__init__(self)
                self.stocks_to_monitor = stocks_to_monitor
                self.duration = duration

            def run(self):
                stdscr = curses.initscr()
                curses.noecho()
                curses.cbreak()

                try:
                    i = 0
                    while duration == -1 or i &lt; duration * 20:
                        y = 0
                        for stock in self.stocks_to_monitor:
                            to_print = stock + &#34;\t&#34; + str(self.__get_stock_price(stock))
                            stdscr.addstr(y, 0, to_print)
                            y += 1

                        stdscr.refresh()
                        time.sleep(0.05)
                        i += 1

                finally:
                    curses.echo()
                    curses.nocbreak()
                    curses.endwin()

            @staticmethod
            def __get_stock_price(stock, rounding=1000):
                return float(int(float(robin_stocks.stocks.get_latest_price(stock)[0]) * rounding) / rounding)

        Stocks_Data_Thread(stocks_to_monitor, duration).start()

    @staticmethod
    def display_holdings(extra_stocks_to_monitor=[], duration=100, show_quantity=False, show_equity=False):
        &#34;&#34;&#34;Turns the command shell executing into a ticker display
        :param extra_stocks_to_monitor: any extra stocks you want towatch
        :type extra_stocks_to_monitor: list [str]
        :param duration: duration in seconds, -1 for infinite
        :type duration: int
        &#34;&#34;&#34;
        class Stocks_Data_Thread(threading.Thread):
            def __init__(self, stocks, show_quantity, show_equity, stocks_to_monitor=[], duration=100):
                threading.Thread.__init__(self)
                self.stocks = stocks
                self.stocks_to_monitor = stocks_to_monitor
                self.duration = duration

                self.show_quantity = show_quantity
                self.show_equity = show_equity

            def run(self):
                stdscr = curses.initscr()
                curses.noecho()
                curses.cbreak()

                try:
                    holdings = robin_stocks.build_holdings()

                    i = 0
                    while duration == -1 or i &lt; duration * 20:
                        y = 0
                        for stock in self.stocks:
                            to_print = stock + &#34;\t&#34; + str(self.__get_stock_price(stock))

                            if self.show_quantity:
                                to_print += &#34;\t&#34; + str(int(float(holdings[stock][&#39;quantity&#39;])))

                            if self.show_equity:
                                to_print += &#34;\t&#34; + str(float(holdings[stock][&#39;equity&#39;]))
                            stdscr.addstr(y, 0, to_print)
                            y += 1

                        if 0 &lt; len(self.stocks_to_monitor):
                            y += 1
                            for stock in self.stocks_to_monitor:
                                if stock not in self.stocks:
                                    stdscr.addstr(y, 0, stock + &#34;\t&#34; + str(self.__get_stock_price(stock)))

                        stdscr.refresh()
                        time.sleep(0.05)
                        i += 1

                finally:
                    curses.echo()
                    curses.nocbreak()
                    curses.endwin()

            @staticmethod
            def __get_stock_price(stock, rounding=1000):
                return float(int(float(robin_stocks.stocks.get_latest_price(stock)[0]) * rounding) / rounding)

        holdings = robin_stocks.account.build_holdings()
        if len(holdings) &lt; 1:
            return

        Stocks_Data_Thread(holdings.keys(), show_quantity, show_equity, extra_stocks_to_monitor, duration).start()

    @staticmethod
    def graph(stock, span=&#39;day&#39;):
        &#34;&#34;&#34;Takes in a single Ticker Symbol and optional span. Displays a matplot graph with the history of that stock, default span to one day
        :param stock: single Stock object
        :type stock: &lt;stock_wrapper.Stock&gt;
        :param span: how far back the graph should span for
        :type span: str, [&#39;day&#39;, &#39;week&#39;, &#39;month&#39;, &#39;3month&#39;, &#39;year&#39;]
        &#34;&#34;&#34;

        def __graph(stock):
            data = stock.get_historical_prices()

            sns.set(style=&#34;darkgrid&#34;)
            ax = sns.lineplot(&#39;begins_at&#39;, &#39;average_price&#39;, data=data)

            #final config
            if span == &#34;day&#34;:
                ax.xaxis.set_major_formatter(md.DateFormatter(&#39;%H:%M:%S&#39;))

            ax.set_title(stock.ticker + &#34;: &#34; + span)
            plt.xlabel(&#34;Date&#34;)
            plt.ylabel(&#34;Price ($)&#34;)

        __graph(stock)
        plt.show()

    @classmethod
    def graph_candlestick_analysis(cls, stocks, cache=True, rangeslider=True, span=&#39;max&#39;):
        &#34;&#34;&#34;Takes in a list of Ticker Symbols and optional span. Displays a matplot graph with the history of that stock, default span to one day
        :param stock: list of Stock objects
        :type stock: list [&lt;stock_wrapper.Stock&gt;]
        :param cache: Whether to cache data in __stock_cache__
        :type cache: bool
        :param span: how far back the graph should span for
        :type span: str, [&#39;day&#39;, &#39;week&#39;, &#39;month&#39;, &#39;3month&#39;, &#39;year&#39;]
        &#34;&#34;&#34;

        def __graph(stock, data):
            sns.set(style=&#34;darkgrid&#34;)

            fig = make_subplots(specs=[[{&#34;secondary_y&#34;: True}]])
            fig.add_trace(go.Candlestick(x=data[&#39;Date&#39;], open=data[&#39;Open&#39;], high=data[&#39;High&#39;], low=data[&#39;Low&#39;], close=data[&#39;Close&#39;], name=stock.ticker + &#39; Market Price&#39;))
            fig.add_trace(go.Scatter(x=data[&#39;Date&#39;], y=data[&#39;10_SMA&#39;], name=&#39;10 Day Moving Average&#39;, marker_color=&#39;rgba(13, 140, 214, .8)&#39;))
            fig.add_trace(go.Scatter(x=data[&#39;Date&#39;], y=data[&#39;20_SMA&#39;], name=&#39;20 Day Moving Average&#39;, marker_color=&#39;rgba(230, 223, 23, .8)&#39;))
            fig.add_trace(go.Scatter(x=data[&#39;Date&#39;], y=data[&#39;100_SMA&#39;], name=&#39;100 Day Moving Average&#39;, marker_color=&#39;rgba(230, 223, 23, .4)&#39;))
            fig.add_trace(go.Scatter(x=data[&#39;Date&#39;], y=data[&#39;200_SMA&#39;], name=&#39;200 Day Moving Average&#39;, marker_color=&#39;rgba(255, 165, 0, .8)&#39;))
            fig.add_trace(go.Scatter(x=data[&#39;Date&#39;], y=data[&#39;Volume&#39;], name=&#39;Volume&#39;, marker_color=&#39;rgba(130, 178, 255, .8)&#39;), secondary_y=True)

            fig.update_layout(xaxis_rangeslider_visible=rangeslider)

            fig.show()

        data = cls.__load_data(stocks, span, cache=cache)

        for i in range(len(data)):
            __graph(stocks[i], data[i])

    @classmethod
    def graph_trendline_analysis(cls, stocks, cache=True, span=&#39;max&#39;):
        &#34;&#34;&#34;Takes in a list of Ticker Symbols and optional span. Displays a matplot graph with the history of that stock, default span to one day
        :param stock: list of Stock objects
        :type stock: list [&lt;stock_wrapper.Stock&gt;]
        :param cache: cache the value in __stock_cache__ folder
        :type cache: bool
        :param span: how far back the graph should span for
        :type span: str, [&#39;day&#39;, &#39;week&#39;, &#39;month&#39;, &#39;3month&#39;, &#39;year&#39;]
        &#34;&#34;&#34;

        def __graph(stock, data):
            sns.set(style=&#34;darkgrid&#34;)

            plt.figure()
            ax = sns.lineplot(x=&#39;Date&#39;, y=&#34;Close&#34;, color=&#39;#82b2ff&#39;, data=data)
            sns.lineplot(x=&#39;Date&#39;, y=&#34;10_SMA&#34;, color=&#39;#0d5ad6&#39;, data=data)
            sns.lineplot(x=&#39;Date&#39;, y=&#34;20_SMA&#34;, color=&#39;#e6df17&#39;, data=data)
            sns.lineplot(x=&#39;Date&#39;, y=&#34;100_SMA&#34;, color=&#39;#ffa500&#39;, data=data)
            sns.lineplot(x=&#39;Date&#39;, y=&#34;200_SMA&#34;, color=&#39;#fc7b03&#39;, data=data)

            close_patch = mpatches.Patch(color=&#39;#82b2ff&#39;, label=&#39;Close Price&#39;)
            sma_10_patch = mpatches.Patch(color=&#39;#0d5ad6&#39;, label=&#39;10 Day Moving Average&#39;)
            sma_20_patch = mpatches.Patch(color=&#39;#e6df17&#39;, label=&#39;20 Day Moving Average&#39;)
            sma_100_patch = mpatches.Patch(color=&#39;#ffa500&#39;, label=&#39;100 Day Moving Average&#39;)
            sma_200_patch = mpatches.Patch(color=&#39;#fc7b03&#39;, label=&#39;200 Day Moving Average&#39;)
            plt.legend(handles=[close_patch, sma_10_patch, sma_20_patch, sma_100_patch, sma_200_patch])

            ax.set_title(stock.ticker)
            plt.gcf().canvas.set_window_title(stock.ticker)
            plt.xlabel(&#34;Date&#34;)
            plt.ylabel(&#34;Price ($)&#34;)

        data = cls.__load_data(stocks, span, cache=cache)

        for i in range(len(data)):
            __graph(stocks[i], data[i])

        plt.show()

    @staticmethod
    def graph_stocks(stock_objects, span=&#39;week&#39;):
        &#34;&#34;&#34;Takes in a list of and optional span. Displays a matplot graph with the history of that stock, default span to one day
        :param stock_objects: list of Stock objects
        :type stock_objects: list &lt;stock_wrapper.Stock&gt;
        :param span: how far back the graph should span for
        :type span: str, [day, week, month, 3month, year, max]
        &#34;&#34;&#34;

        f, axes = plt.subplots(int(np.ceil(len(stock_objects) / 3)), 3, figsize=(8, 6))

        def __graph(data, row, col, axes):
            chart = sns.lineplot(&#39;begins_at&#39;, &#39;average_price&#39;, data=data, ax=axes[row, col])
            chart.set_xlabel(&#34;Date&#34;)
            plt.setp(chart.get_xticklabels(), rotation=45)
            # chart.set_xticklabels(chart.get_xticklabels(), rotation=5, horizontalalignment=&#39;right&#39;)
            chart.set_ylabel(&#34;Price ($)&#34;)

            #final config
            if span == &#34;day&#34;:
                chart.xaxis.set_major_formatter(md.DateFormatter(&#39;%H:%M:%S&#39;))

        i = 0
        for row in range(int(np.ceil(len(stock_objects) / 3))):
            for col in range(3):
                if i &lt; len(stock_objects):
                    axes[row][col].set_title(stock_objects[i].ticker)
                    __graph(stock_objects[i].get_historical_prices(span=span), row, col, axes)
                i += 1

        # chart config
        sns.despine(left=True)
        sns.set(style=&#34;dark&#34;)

        plt.show()

    @staticmethod
    def __load_data(stocks, span, cache=True):
        converter = {&#39;week&#39;: &#39;1m&#39;, &#39;month&#39;:&#39;30m&#39;, &#39;max&#39;: &#39;1d&#39;}

        # def __gather_data(i, list, symbol):
        #     list[i] = stock_wrapper.data.get_history(symbol, span=&#39;week&#39;, interval=converter[span], cache=cache)
        #
        # threads = []
        histories = []
        # for i in range(len(stocks)):
        #     thread = threading.Thread(target=__gather_data, args=(i, histories, stocks[i].ticker))
        #     threads.append(thread)
        #     thread.start()
        #
        # for thread in threads:
        #     thread.join()

        for stock in stocks:
            histories.append(stock_wrapper.data.get_history(stock.ticker, span=span, interval=converter[span], cache=cache))

        return histories</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="stock_wrapper.visualize.visualize"><code class="flex name class">
<span>class <span class="ident">visualize</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class visualize:
    @staticmethod
    def display_stocks(stocks_to_monitor, duration=100):
        &#34;&#34;&#34;Turns the command shell executing into a ticker display
        :param stocks_to_monitor: any stocks you want to watch
        :type stocks_to_monitor: list [str]
        :param duration: duration in seconds, -1 for infinite
        :type duration: int
        &#34;&#34;&#34;
        if len(stocks_to_monitor) &lt; 1:
            return

        class Stocks_Data_Thread(threading.Thread):
            def __init__(self, stocks_to_monitor, duration=100):
                threading.Thread.__init__(self)
                self.stocks_to_monitor = stocks_to_monitor
                self.duration = duration

            def run(self):
                stdscr = curses.initscr()
                curses.noecho()
                curses.cbreak()

                try:
                    i = 0
                    while duration == -1 or i &lt; duration * 20:
                        y = 0
                        for stock in self.stocks_to_monitor:
                            to_print = stock + &#34;\t&#34; + str(self.__get_stock_price(stock))
                            stdscr.addstr(y, 0, to_print)
                            y += 1

                        stdscr.refresh()
                        time.sleep(0.05)
                        i += 1

                finally:
                    curses.echo()
                    curses.nocbreak()
                    curses.endwin()

            @staticmethod
            def __get_stock_price(stock, rounding=1000):
                return float(int(float(robin_stocks.stocks.get_latest_price(stock)[0]) * rounding) / rounding)

        Stocks_Data_Thread(stocks_to_monitor, duration).start()

    @staticmethod
    def display_holdings(extra_stocks_to_monitor=[], duration=100, show_quantity=False, show_equity=False):
        &#34;&#34;&#34;Turns the command shell executing into a ticker display
        :param extra_stocks_to_monitor: any extra stocks you want towatch
        :type extra_stocks_to_monitor: list [str]
        :param duration: duration in seconds, -1 for infinite
        :type duration: int
        &#34;&#34;&#34;
        class Stocks_Data_Thread(threading.Thread):
            def __init__(self, stocks, show_quantity, show_equity, stocks_to_monitor=[], duration=100):
                threading.Thread.__init__(self)
                self.stocks = stocks
                self.stocks_to_monitor = stocks_to_monitor
                self.duration = duration

                self.show_quantity = show_quantity
                self.show_equity = show_equity

            def run(self):
                stdscr = curses.initscr()
                curses.noecho()
                curses.cbreak()

                try:
                    holdings = robin_stocks.build_holdings()

                    i = 0
                    while duration == -1 or i &lt; duration * 20:
                        y = 0
                        for stock in self.stocks:
                            to_print = stock + &#34;\t&#34; + str(self.__get_stock_price(stock))

                            if self.show_quantity:
                                to_print += &#34;\t&#34; + str(int(float(holdings[stock][&#39;quantity&#39;])))

                            if self.show_equity:
                                to_print += &#34;\t&#34; + str(float(holdings[stock][&#39;equity&#39;]))
                            stdscr.addstr(y, 0, to_print)
                            y += 1

                        if 0 &lt; len(self.stocks_to_monitor):
                            y += 1
                            for stock in self.stocks_to_monitor:
                                if stock not in self.stocks:
                                    stdscr.addstr(y, 0, stock + &#34;\t&#34; + str(self.__get_stock_price(stock)))

                        stdscr.refresh()
                        time.sleep(0.05)
                        i += 1

                finally:
                    curses.echo()
                    curses.nocbreak()
                    curses.endwin()

            @staticmethod
            def __get_stock_price(stock, rounding=1000):
                return float(int(float(robin_stocks.stocks.get_latest_price(stock)[0]) * rounding) / rounding)

        holdings = robin_stocks.account.build_holdings()
        if len(holdings) &lt; 1:
            return

        Stocks_Data_Thread(holdings.keys(), show_quantity, show_equity, extra_stocks_to_monitor, duration).start()

    @staticmethod
    def graph(stock, span=&#39;day&#39;):
        &#34;&#34;&#34;Takes in a single Ticker Symbol and optional span. Displays a matplot graph with the history of that stock, default span to one day
        :param stock: single Stock object
        :type stock: &lt;stock_wrapper.Stock&gt;
        :param span: how far back the graph should span for
        :type span: str, [&#39;day&#39;, &#39;week&#39;, &#39;month&#39;, &#39;3month&#39;, &#39;year&#39;]
        &#34;&#34;&#34;

        def __graph(stock):
            data = stock.get_historical_prices()

            sns.set(style=&#34;darkgrid&#34;)
            ax = sns.lineplot(&#39;begins_at&#39;, &#39;average_price&#39;, data=data)

            #final config
            if span == &#34;day&#34;:
                ax.xaxis.set_major_formatter(md.DateFormatter(&#39;%H:%M:%S&#39;))

            ax.set_title(stock.ticker + &#34;: &#34; + span)
            plt.xlabel(&#34;Date&#34;)
            plt.ylabel(&#34;Price ($)&#34;)

        __graph(stock)
        plt.show()

    @classmethod
    def graph_candlestick_analysis(cls, stocks, cache=True, rangeslider=True, span=&#39;max&#39;):
        &#34;&#34;&#34;Takes in a list of Ticker Symbols and optional span. Displays a matplot graph with the history of that stock, default span to one day
        :param stock: list of Stock objects
        :type stock: list [&lt;stock_wrapper.Stock&gt;]
        :param cache: Whether to cache data in __stock_cache__
        :type cache: bool
        :param span: how far back the graph should span for
        :type span: str, [&#39;day&#39;, &#39;week&#39;, &#39;month&#39;, &#39;3month&#39;, &#39;year&#39;]
        &#34;&#34;&#34;

        def __graph(stock, data):
            sns.set(style=&#34;darkgrid&#34;)

            fig = make_subplots(specs=[[{&#34;secondary_y&#34;: True}]])
            fig.add_trace(go.Candlestick(x=data[&#39;Date&#39;], open=data[&#39;Open&#39;], high=data[&#39;High&#39;], low=data[&#39;Low&#39;], close=data[&#39;Close&#39;], name=stock.ticker + &#39; Market Price&#39;))
            fig.add_trace(go.Scatter(x=data[&#39;Date&#39;], y=data[&#39;10_SMA&#39;], name=&#39;10 Day Moving Average&#39;, marker_color=&#39;rgba(13, 140, 214, .8)&#39;))
            fig.add_trace(go.Scatter(x=data[&#39;Date&#39;], y=data[&#39;20_SMA&#39;], name=&#39;20 Day Moving Average&#39;, marker_color=&#39;rgba(230, 223, 23, .8)&#39;))
            fig.add_trace(go.Scatter(x=data[&#39;Date&#39;], y=data[&#39;100_SMA&#39;], name=&#39;100 Day Moving Average&#39;, marker_color=&#39;rgba(230, 223, 23, .4)&#39;))
            fig.add_trace(go.Scatter(x=data[&#39;Date&#39;], y=data[&#39;200_SMA&#39;], name=&#39;200 Day Moving Average&#39;, marker_color=&#39;rgba(255, 165, 0, .8)&#39;))
            fig.add_trace(go.Scatter(x=data[&#39;Date&#39;], y=data[&#39;Volume&#39;], name=&#39;Volume&#39;, marker_color=&#39;rgba(130, 178, 255, .8)&#39;), secondary_y=True)

            fig.update_layout(xaxis_rangeslider_visible=rangeslider)

            fig.show()

        data = cls.__load_data(stocks, span, cache=cache)

        for i in range(len(data)):
            __graph(stocks[i], data[i])

    @classmethod
    def graph_trendline_analysis(cls, stocks, cache=True, span=&#39;max&#39;):
        &#34;&#34;&#34;Takes in a list of Ticker Symbols and optional span. Displays a matplot graph with the history of that stock, default span to one day
        :param stock: list of Stock objects
        :type stock: list [&lt;stock_wrapper.Stock&gt;]
        :param cache: cache the value in __stock_cache__ folder
        :type cache: bool
        :param span: how far back the graph should span for
        :type span: str, [&#39;day&#39;, &#39;week&#39;, &#39;month&#39;, &#39;3month&#39;, &#39;year&#39;]
        &#34;&#34;&#34;

        def __graph(stock, data):
            sns.set(style=&#34;darkgrid&#34;)

            plt.figure()
            ax = sns.lineplot(x=&#39;Date&#39;, y=&#34;Close&#34;, color=&#39;#82b2ff&#39;, data=data)
            sns.lineplot(x=&#39;Date&#39;, y=&#34;10_SMA&#34;, color=&#39;#0d5ad6&#39;, data=data)
            sns.lineplot(x=&#39;Date&#39;, y=&#34;20_SMA&#34;, color=&#39;#e6df17&#39;, data=data)
            sns.lineplot(x=&#39;Date&#39;, y=&#34;100_SMA&#34;, color=&#39;#ffa500&#39;, data=data)
            sns.lineplot(x=&#39;Date&#39;, y=&#34;200_SMA&#34;, color=&#39;#fc7b03&#39;, data=data)

            close_patch = mpatches.Patch(color=&#39;#82b2ff&#39;, label=&#39;Close Price&#39;)
            sma_10_patch = mpatches.Patch(color=&#39;#0d5ad6&#39;, label=&#39;10 Day Moving Average&#39;)
            sma_20_patch = mpatches.Patch(color=&#39;#e6df17&#39;, label=&#39;20 Day Moving Average&#39;)
            sma_100_patch = mpatches.Patch(color=&#39;#ffa500&#39;, label=&#39;100 Day Moving Average&#39;)
            sma_200_patch = mpatches.Patch(color=&#39;#fc7b03&#39;, label=&#39;200 Day Moving Average&#39;)
            plt.legend(handles=[close_patch, sma_10_patch, sma_20_patch, sma_100_patch, sma_200_patch])

            ax.set_title(stock.ticker)
            plt.gcf().canvas.set_window_title(stock.ticker)
            plt.xlabel(&#34;Date&#34;)
            plt.ylabel(&#34;Price ($)&#34;)

        data = cls.__load_data(stocks, span, cache=cache)

        for i in range(len(data)):
            __graph(stocks[i], data[i])

        plt.show()

    @staticmethod
    def graph_stocks(stock_objects, span=&#39;week&#39;):
        &#34;&#34;&#34;Takes in a list of and optional span. Displays a matplot graph with the history of that stock, default span to one day
        :param stock_objects: list of Stock objects
        :type stock_objects: list &lt;stock_wrapper.Stock&gt;
        :param span: how far back the graph should span for
        :type span: str, [day, week, month, 3month, year, max]
        &#34;&#34;&#34;

        f, axes = plt.subplots(int(np.ceil(len(stock_objects) / 3)), 3, figsize=(8, 6))

        def __graph(data, row, col, axes):
            chart = sns.lineplot(&#39;begins_at&#39;, &#39;average_price&#39;, data=data, ax=axes[row, col])
            chart.set_xlabel(&#34;Date&#34;)
            plt.setp(chart.get_xticklabels(), rotation=45)
            # chart.set_xticklabels(chart.get_xticklabels(), rotation=5, horizontalalignment=&#39;right&#39;)
            chart.set_ylabel(&#34;Price ($)&#34;)

            #final config
            if span == &#34;day&#34;:
                chart.xaxis.set_major_formatter(md.DateFormatter(&#39;%H:%M:%S&#39;))

        i = 0
        for row in range(int(np.ceil(len(stock_objects) / 3))):
            for col in range(3):
                if i &lt; len(stock_objects):
                    axes[row][col].set_title(stock_objects[i].ticker)
                    __graph(stock_objects[i].get_historical_prices(span=span), row, col, axes)
                i += 1

        # chart config
        sns.despine(left=True)
        sns.set(style=&#34;dark&#34;)

        plt.show()

    @staticmethod
    def __load_data(stocks, span, cache=True):
        converter = {&#39;week&#39;: &#39;1m&#39;, &#39;month&#39;:&#39;30m&#39;, &#39;max&#39;: &#39;1d&#39;}

        # def __gather_data(i, list, symbol):
        #     list[i] = stock_wrapper.data.get_history(symbol, span=&#39;week&#39;, interval=converter[span], cache=cache)
        #
        # threads = []
        histories = []
        # for i in range(len(stocks)):
        #     thread = threading.Thread(target=__gather_data, args=(i, histories, stocks[i].ticker))
        #     threads.append(thread)
        #     thread.start()
        #
        # for thread in threads:
        #     thread.join()

        for stock in stocks:
            histories.append(stock_wrapper.data.get_history(stock.ticker, span=span, interval=converter[span], cache=cache))

        return histories</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="stock_wrapper.visualize.visualize.display_holdings"><code class="name flex">
<span>def <span class="ident">display_holdings</span></span>(<span>extra_stocks_to_monitor=[], duration=100, show_quantity=False, show_equity=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Turns the command shell executing into a ticker display
:param extra_stocks_to_monitor: any extra stocks you want towatch
:type extra_stocks_to_monitor: list [str]
:param duration: duration in seconds, -1 for infinite
:type duration: int</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def display_holdings(extra_stocks_to_monitor=[], duration=100, show_quantity=False, show_equity=False):
    &#34;&#34;&#34;Turns the command shell executing into a ticker display
    :param extra_stocks_to_monitor: any extra stocks you want towatch
    :type extra_stocks_to_monitor: list [str]
    :param duration: duration in seconds, -1 for infinite
    :type duration: int
    &#34;&#34;&#34;
    class Stocks_Data_Thread(threading.Thread):
        def __init__(self, stocks, show_quantity, show_equity, stocks_to_monitor=[], duration=100):
            threading.Thread.__init__(self)
            self.stocks = stocks
            self.stocks_to_monitor = stocks_to_monitor
            self.duration = duration

            self.show_quantity = show_quantity
            self.show_equity = show_equity

        def run(self):
            stdscr = curses.initscr()
            curses.noecho()
            curses.cbreak()

            try:
                holdings = robin_stocks.build_holdings()

                i = 0
                while duration == -1 or i &lt; duration * 20:
                    y = 0
                    for stock in self.stocks:
                        to_print = stock + &#34;\t&#34; + str(self.__get_stock_price(stock))

                        if self.show_quantity:
                            to_print += &#34;\t&#34; + str(int(float(holdings[stock][&#39;quantity&#39;])))

                        if self.show_equity:
                            to_print += &#34;\t&#34; + str(float(holdings[stock][&#39;equity&#39;]))
                        stdscr.addstr(y, 0, to_print)
                        y += 1

                    if 0 &lt; len(self.stocks_to_monitor):
                        y += 1
                        for stock in self.stocks_to_monitor:
                            if stock not in self.stocks:
                                stdscr.addstr(y, 0, stock + &#34;\t&#34; + str(self.__get_stock_price(stock)))

                    stdscr.refresh()
                    time.sleep(0.05)
                    i += 1

            finally:
                curses.echo()
                curses.nocbreak()
                curses.endwin()

        @staticmethod
        def __get_stock_price(stock, rounding=1000):
            return float(int(float(robin_stocks.stocks.get_latest_price(stock)[0]) * rounding) / rounding)

    holdings = robin_stocks.account.build_holdings()
    if len(holdings) &lt; 1:
        return

    Stocks_Data_Thread(holdings.keys(), show_quantity, show_equity, extra_stocks_to_monitor, duration).start()</code></pre>
</details>
</dd>
<dt id="stock_wrapper.visualize.visualize.display_stocks"><code class="name flex">
<span>def <span class="ident">display_stocks</span></span>(<span>stocks_to_monitor, duration=100)</span>
</code></dt>
<dd>
<div class="desc"><p>Turns the command shell executing into a ticker display
:param stocks_to_monitor: any stocks you want to watch
:type stocks_to_monitor: list [str]
:param duration: duration in seconds, -1 for infinite
:type duration: int</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def display_stocks(stocks_to_monitor, duration=100):
    &#34;&#34;&#34;Turns the command shell executing into a ticker display
    :param stocks_to_monitor: any stocks you want to watch
    :type stocks_to_monitor: list [str]
    :param duration: duration in seconds, -1 for infinite
    :type duration: int
    &#34;&#34;&#34;
    if len(stocks_to_monitor) &lt; 1:
        return

    class Stocks_Data_Thread(threading.Thread):
        def __init__(self, stocks_to_monitor, duration=100):
            threading.Thread.__init__(self)
            self.stocks_to_monitor = stocks_to_monitor
            self.duration = duration

        def run(self):
            stdscr = curses.initscr()
            curses.noecho()
            curses.cbreak()

            try:
                i = 0
                while duration == -1 or i &lt; duration * 20:
                    y = 0
                    for stock in self.stocks_to_monitor:
                        to_print = stock + &#34;\t&#34; + str(self.__get_stock_price(stock))
                        stdscr.addstr(y, 0, to_print)
                        y += 1

                    stdscr.refresh()
                    time.sleep(0.05)
                    i += 1

            finally:
                curses.echo()
                curses.nocbreak()
                curses.endwin()

        @staticmethod
        def __get_stock_price(stock, rounding=1000):
            return float(int(float(robin_stocks.stocks.get_latest_price(stock)[0]) * rounding) / rounding)

    Stocks_Data_Thread(stocks_to_monitor, duration).start()</code></pre>
</details>
</dd>
<dt id="stock_wrapper.visualize.visualize.graph"><code class="name flex">
<span>def <span class="ident">graph</span></span>(<span>stock, span='day')</span>
</code></dt>
<dd>
<div class="desc"><p>Takes in a single Ticker Symbol and optional span. Displays a matplot graph with the history of that stock, default span to one day
:param stock: single Stock object
:type stock: <stock_wrapper.Stock>
:param span: how far back the graph should span for
:type span: str, ['day', 'week', 'month', '3month', 'year']</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def graph(stock, span=&#39;day&#39;):
    &#34;&#34;&#34;Takes in a single Ticker Symbol and optional span. Displays a matplot graph with the history of that stock, default span to one day
    :param stock: single Stock object
    :type stock: &lt;stock_wrapper.Stock&gt;
    :param span: how far back the graph should span for
    :type span: str, [&#39;day&#39;, &#39;week&#39;, &#39;month&#39;, &#39;3month&#39;, &#39;year&#39;]
    &#34;&#34;&#34;

    def __graph(stock):
        data = stock.get_historical_prices()

        sns.set(style=&#34;darkgrid&#34;)
        ax = sns.lineplot(&#39;begins_at&#39;, &#39;average_price&#39;, data=data)

        #final config
        if span == &#34;day&#34;:
            ax.xaxis.set_major_formatter(md.DateFormatter(&#39;%H:%M:%S&#39;))

        ax.set_title(stock.ticker + &#34;: &#34; + span)
        plt.xlabel(&#34;Date&#34;)
        plt.ylabel(&#34;Price ($)&#34;)

    __graph(stock)
    plt.show()</code></pre>
</details>
</dd>
<dt id="stock_wrapper.visualize.visualize.graph_candlestick_analysis"><code class="name flex">
<span>def <span class="ident">graph_candlestick_analysis</span></span>(<span>stocks, cache=True, rangeslider=True, span='max')</span>
</code></dt>
<dd>
<div class="desc"><p>Takes in a list of Ticker Symbols and optional span. Displays a matplot graph with the history of that stock, default span to one day
:param stock: list of Stock objects
:type stock: list [<stock_wrapper.Stock>]
:param cache: Whether to cache data in <strong>stock_cache</strong>
:type cache: bool
:param span: how far back the graph should span for
:type span: str, ['day', 'week', 'month', '3month', 'year']</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def graph_candlestick_analysis(cls, stocks, cache=True, rangeslider=True, span=&#39;max&#39;):
    &#34;&#34;&#34;Takes in a list of Ticker Symbols and optional span. Displays a matplot graph with the history of that stock, default span to one day
    :param stock: list of Stock objects
    :type stock: list [&lt;stock_wrapper.Stock&gt;]
    :param cache: Whether to cache data in __stock_cache__
    :type cache: bool
    :param span: how far back the graph should span for
    :type span: str, [&#39;day&#39;, &#39;week&#39;, &#39;month&#39;, &#39;3month&#39;, &#39;year&#39;]
    &#34;&#34;&#34;

    def __graph(stock, data):
        sns.set(style=&#34;darkgrid&#34;)

        fig = make_subplots(specs=[[{&#34;secondary_y&#34;: True}]])
        fig.add_trace(go.Candlestick(x=data[&#39;Date&#39;], open=data[&#39;Open&#39;], high=data[&#39;High&#39;], low=data[&#39;Low&#39;], close=data[&#39;Close&#39;], name=stock.ticker + &#39; Market Price&#39;))
        fig.add_trace(go.Scatter(x=data[&#39;Date&#39;], y=data[&#39;10_SMA&#39;], name=&#39;10 Day Moving Average&#39;, marker_color=&#39;rgba(13, 140, 214, .8)&#39;))
        fig.add_trace(go.Scatter(x=data[&#39;Date&#39;], y=data[&#39;20_SMA&#39;], name=&#39;20 Day Moving Average&#39;, marker_color=&#39;rgba(230, 223, 23, .8)&#39;))
        fig.add_trace(go.Scatter(x=data[&#39;Date&#39;], y=data[&#39;100_SMA&#39;], name=&#39;100 Day Moving Average&#39;, marker_color=&#39;rgba(230, 223, 23, .4)&#39;))
        fig.add_trace(go.Scatter(x=data[&#39;Date&#39;], y=data[&#39;200_SMA&#39;], name=&#39;200 Day Moving Average&#39;, marker_color=&#39;rgba(255, 165, 0, .8)&#39;))
        fig.add_trace(go.Scatter(x=data[&#39;Date&#39;], y=data[&#39;Volume&#39;], name=&#39;Volume&#39;, marker_color=&#39;rgba(130, 178, 255, .8)&#39;), secondary_y=True)

        fig.update_layout(xaxis_rangeslider_visible=rangeslider)

        fig.show()

    data = cls.__load_data(stocks, span, cache=cache)

    for i in range(len(data)):
        __graph(stocks[i], data[i])</code></pre>
</details>
</dd>
<dt id="stock_wrapper.visualize.visualize.graph_stocks"><code class="name flex">
<span>def <span class="ident">graph_stocks</span></span>(<span>stock_objects, span='week')</span>
</code></dt>
<dd>
<div class="desc"><p>Takes in a list of and optional span. Displays a matplot graph with the history of that stock, default span to one day
:param stock_objects: list of Stock objects
:type stock_objects: list <stock_wrapper.Stock>
:param span: how far back the graph should span for
:type span: str, [day, week, month, 3month, year, max]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def graph_stocks(stock_objects, span=&#39;week&#39;):
    &#34;&#34;&#34;Takes in a list of and optional span. Displays a matplot graph with the history of that stock, default span to one day
    :param stock_objects: list of Stock objects
    :type stock_objects: list &lt;stock_wrapper.Stock&gt;
    :param span: how far back the graph should span for
    :type span: str, [day, week, month, 3month, year, max]
    &#34;&#34;&#34;

    f, axes = plt.subplots(int(np.ceil(len(stock_objects) / 3)), 3, figsize=(8, 6))

    def __graph(data, row, col, axes):
        chart = sns.lineplot(&#39;begins_at&#39;, &#39;average_price&#39;, data=data, ax=axes[row, col])
        chart.set_xlabel(&#34;Date&#34;)
        plt.setp(chart.get_xticklabels(), rotation=45)
        # chart.set_xticklabels(chart.get_xticklabels(), rotation=5, horizontalalignment=&#39;right&#39;)
        chart.set_ylabel(&#34;Price ($)&#34;)

        #final config
        if span == &#34;day&#34;:
            chart.xaxis.set_major_formatter(md.DateFormatter(&#39;%H:%M:%S&#39;))

    i = 0
    for row in range(int(np.ceil(len(stock_objects) / 3))):
        for col in range(3):
            if i &lt; len(stock_objects):
                axes[row][col].set_title(stock_objects[i].ticker)
                __graph(stock_objects[i].get_historical_prices(span=span), row, col, axes)
            i += 1

    # chart config
    sns.despine(left=True)
    sns.set(style=&#34;dark&#34;)

    plt.show()</code></pre>
</details>
</dd>
<dt id="stock_wrapper.visualize.visualize.graph_trendline_analysis"><code class="name flex">
<span>def <span class="ident">graph_trendline_analysis</span></span>(<span>stocks, cache=True, span='max')</span>
</code></dt>
<dd>
<div class="desc"><p>Takes in a list of Ticker Symbols and optional span. Displays a matplot graph with the history of that stock, default span to one day
:param stock: list of Stock objects
:type stock: list [<stock_wrapper.Stock>]
:param cache: cache the value in <strong>stock_cache</strong> folder
:type cache: bool
:param span: how far back the graph should span for
:type span: str, ['day', 'week', 'month', '3month', 'year']</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def graph_trendline_analysis(cls, stocks, cache=True, span=&#39;max&#39;):
    &#34;&#34;&#34;Takes in a list of Ticker Symbols and optional span. Displays a matplot graph with the history of that stock, default span to one day
    :param stock: list of Stock objects
    :type stock: list [&lt;stock_wrapper.Stock&gt;]
    :param cache: cache the value in __stock_cache__ folder
    :type cache: bool
    :param span: how far back the graph should span for
    :type span: str, [&#39;day&#39;, &#39;week&#39;, &#39;month&#39;, &#39;3month&#39;, &#39;year&#39;]
    &#34;&#34;&#34;

    def __graph(stock, data):
        sns.set(style=&#34;darkgrid&#34;)

        plt.figure()
        ax = sns.lineplot(x=&#39;Date&#39;, y=&#34;Close&#34;, color=&#39;#82b2ff&#39;, data=data)
        sns.lineplot(x=&#39;Date&#39;, y=&#34;10_SMA&#34;, color=&#39;#0d5ad6&#39;, data=data)
        sns.lineplot(x=&#39;Date&#39;, y=&#34;20_SMA&#34;, color=&#39;#e6df17&#39;, data=data)
        sns.lineplot(x=&#39;Date&#39;, y=&#34;100_SMA&#34;, color=&#39;#ffa500&#39;, data=data)
        sns.lineplot(x=&#39;Date&#39;, y=&#34;200_SMA&#34;, color=&#39;#fc7b03&#39;, data=data)

        close_patch = mpatches.Patch(color=&#39;#82b2ff&#39;, label=&#39;Close Price&#39;)
        sma_10_patch = mpatches.Patch(color=&#39;#0d5ad6&#39;, label=&#39;10 Day Moving Average&#39;)
        sma_20_patch = mpatches.Patch(color=&#39;#e6df17&#39;, label=&#39;20 Day Moving Average&#39;)
        sma_100_patch = mpatches.Patch(color=&#39;#ffa500&#39;, label=&#39;100 Day Moving Average&#39;)
        sma_200_patch = mpatches.Patch(color=&#39;#fc7b03&#39;, label=&#39;200 Day Moving Average&#39;)
        plt.legend(handles=[close_patch, sma_10_patch, sma_20_patch, sma_100_patch, sma_200_patch])

        ax.set_title(stock.ticker)
        plt.gcf().canvas.set_window_title(stock.ticker)
        plt.xlabel(&#34;Date&#34;)
        plt.ylabel(&#34;Price ($)&#34;)

    data = cls.__load_data(stocks, span, cache=cache)

    for i in range(len(data)):
        __graph(stocks[i], data[i])

    plt.show()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="stock_wrapper" href="index.html">stock_wrapper</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="stock_wrapper.visualize.visualize" href="#stock_wrapper.visualize.visualize">visualize</a></code></h4>
<ul class="">
<li><code><a title="stock_wrapper.visualize.visualize.display_holdings" href="#stock_wrapper.visualize.visualize.display_holdings">display_holdings</a></code></li>
<li><code><a title="stock_wrapper.visualize.visualize.display_stocks" href="#stock_wrapper.visualize.visualize.display_stocks">display_stocks</a></code></li>
<li><code><a title="stock_wrapper.visualize.visualize.graph" href="#stock_wrapper.visualize.visualize.graph">graph</a></code></li>
<li><code><a title="stock_wrapper.visualize.visualize.graph_candlestick_analysis" href="#stock_wrapper.visualize.visualize.graph_candlestick_analysis">graph_candlestick_analysis</a></code></li>
<li><code><a title="stock_wrapper.visualize.visualize.graph_stocks" href="#stock_wrapper.visualize.visualize.graph_stocks">graph_stocks</a></code></li>
<li><code><a title="stock_wrapper.visualize.visualize.graph_trendline_analysis" href="#stock_wrapper.visualize.visualize.graph_trendline_analysis">graph_trendline_analysis</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>